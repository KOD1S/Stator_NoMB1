import concurrent.futures
import numpy as np
import pandas as pd
import igraph as ig
import scipy
from scipy.stats import norm
import numba
from numba import njit

def findMarkovBlanket(v, g):
    '''
    Markov blanket is all parents, children, and spouses.
    i.e. the parents of your chidren, except yourself
    '''
    parents = g.neighbors(v, mode='IN')
    children = g.neighbors(v, mode='OUT')
    spouses = [spouse for s in [g.neighbors(child, mode='IN') for child in children] 
               for spouse in s if (spouse != v)] #Nested for loops to flatten list
    
    return list(set(parents + children + spouses)) #Sets to keep uniques
   
    
def conditionOnMB(genes, graph, dataSet, mode='0', genesToOne=[]):
    '''
    Calculate the MB for each gene in genes, and set all to zero. 
    mode=='Min' uses the smallest blanket, 
    while an integer specifies a particular gene's MB
    '''
    MBs = [findMarkovBlanket(gene, graph) for gene in genes]

    if (mode == 'Min'):
        MB = min(MBs, key=len) 
    elif (mode == 'All'):
        MB = [gene for MB in MBs for gene in MB]      
    else:
        try:
            MB = MBs[int(mode)]
        except:
            print('Invalid mode')

    MB = list(set(MB) - set(genes)) #Remove the interacting genes from the markov Blanket.    
    
    condState = [1 if gene in genesToOne else 0 for gene in MB]

    data_conditioned = dataSet[(dataSet.iloc[:, MB]==condState).all(axis=1)] #Set whole MB to conditioned state.     
    return data_conditioned.iloc[:, genes]

def findLocalGraph(v, g, order):
    '''
    Given a graph and a vertex, find the local graph strucure by returning the subgraph generated by taking [order] steps on the graph. 
    '''
    nodes = set([*v])
    for i in range(order):
        newNodes = set()
        for node in nodes:
            newNodes = newNodes.union(set(g.neighbors(node)))
        nodes = nodes.union(newNodes)
    return g.subgraph(list(nodes))

from itertools import chain, combinations

def powerset(iterable):
    items = list(iterable)
    return chain.from_iterable(combinations(items,n) for n in range(len(items)+1))

@njit(cache=True)
def safeMean(a):
    if len(a)>0:
        return a.mean()
    else:
        return 0

@njit(cache=True)
def fastBinCount(conditionedGenes, order):
    bases = np.array([2**x for x in range(order)][::-1], dtype=np.float32)
    return np.bincount(np.dot(bases, conditionedGenes.T).astype(np.int32), minlength=int(2**order))

@njit(cache=True)
def calcInteraction_expectations_numba(conditionedGenes_np):
    '''
    Calc the interactions from the conditioned data using expectation values. 
    Could see if using probabilities is faster. 
    Currently, orders are implemented separately.
    '''
    if (len(conditionedGenes_np)==0):
        return np.nan
    
    order = conditionedGenes_np.shape[-1]
    
    
    if(order==1):
        E = safeMean(conditionedGenes_np)
        num = E
        denom = 1-E
        
    elif(order==2):
        E1 = safeMean(conditionedGenes_np[conditionedGenes_np[:, 1]==1][:, 0])
        E0 = safeMean(conditionedGenes_np[conditionedGenes_np[:, 1]==0][:, 0])

        num = E1*(1-E0)
        denom = E0*(1-E1)
        
    elif(order==3):
        E11 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1)][:, 0])
        E00 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0)][:, 0])
        E10 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0)][:, 0])
        E01 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1)][:, 0])
        num = E11*(1-E01)*E00*(1-E10)
        denom = E01*(1-E11)*E10*(1-E00)
        
    elif(order==4):
        E111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1)][:, 0])
        E000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0)][:, 0])
        
        E001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1)][:, 0])
        E010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0)][:, 0])
        E100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0)][:, 0])
        
        E011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1)][:, 0])
        E101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1)][:, 0])
        E110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0)][:, 0])
        
       
        num = E111*(1-E011)*(1-E101)*E001*E010*(1-E110)*E100*(1-E000)
        denom = (1-E111)*E011*E101*(1-E001)*(1-E010)*E110*(1-E100)*E000 
    elif(order==5):
        E1111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        E0000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        
        E0001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        E0010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        E0100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        E1000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        
        E0011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        E0101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        E0110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        E1010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        E1100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        E1001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        
        E1110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0)][:, 0])  
        E1101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        E1011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        E0111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1)][:, 0])  
        
        num = E1111*E1100*E1010*E0110*E0101*E0011*E1001*E0000 * (1-E0111)*(1-E1011)*(1-E1101)*(1-E1110)*(1-E0001)*(1-E0010)*(1-E0100)*(1-E1000)
        denom = (1-E1111)*(1-E1100)*(1-E1010)*(1-E0110)*(1-E0101)*(1-E0011)*(1-E1001)*(1-E0000)*(E0111*E1011*E1101*E1110*E0001*E0010*E0100*E1000)
    elif(order==6):
        E11110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E00000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E00010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E00100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E01000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E10000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E00110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E01010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E01100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E10100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E11000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E10010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E11100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E11010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E10110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  
        E01110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0)][:, 0])  

        E11111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E00001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E00011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E00101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E01001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E10001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E00111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E01011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E01101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E10101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E11001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E10011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E11101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E11011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E10111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  
        E01111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1)][:, 0])  


        num = E11111*E11001*E10101*E01101*E01011*E00111*E10011*E00001 * (1-E01111)*(1-E10111)*(1-E11011)*(1-E11101)*(1-E00011)*(1-E00101)*(1-E01001)*(1-E10001) * \
                (1-E11110)*(1-E11000)*(1-E10100)*(1-E01100)*(1-E01010)*(1-E00110)*(1-E10010)*(1-E00000)*(E01110*E10110*E11010*E11100*E00010*E00100*E01000*E10000)

        denom = (1-E11111)*(1-E11001)*(1-E10101)*(1-E01101)*(1-E01011)*(1-E00111)*(1-E10011)*(1-E00001)*(E01111*E10111*E11011*E11101*E00011*E00101*E01001*E10001) * \
                E11110*E11000*E10100*E01100*E01010*E00110*E10010*E00000 * (1-E01110)*(1-E10110)*(1-E11010)*(1-E11100)*(1-E00010)*(1-E00100)*(1-E01000)*(1-E10000)
    elif(order==7):
        E111101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E000001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E000101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E001001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E010001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E100001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E001101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E010101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E011001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E101001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E110001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E100101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E111001 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E110101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E101101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E011101 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E111111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E000011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E000111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E001011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E010011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E100011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E001111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E010111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E011011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E101011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E110011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E100111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E111011 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E110111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E101111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  
        E011111 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==1)][:, 0])  

        E111100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E000000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E000100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E001000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E010000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E100000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E001100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E010100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E011000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E101000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E110000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E100100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E111000 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E110100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E101100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E011100 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==0) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E111110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E000010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E000110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E001010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E010010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E100010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E001110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E010110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E011010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E101010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E110010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E100110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E111010 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==0) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E110110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==0) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E101110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0])  
        E011110 = safeMean(conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1) & (conditionedGenes_np[:, 3]==1) & (conditionedGenes_np[:, 4]==1) & (conditionedGenes_np[:, 5]==1) & (conditionedGenes_np[:, 6]==0)][:, 0]) 


        num = E111111*E110011*E101011*E011011*E010111*E001111*E100111*E000011 * (1-E011111)*(1-E101111)*(1-E110111)*(1-E111011)*(1-E000111)*(1-E001011)*(1-E010011)*(1-E100011) * \
                (1-E111101)*(1-E110001)*(1-E101001)*(1-E011001)*(1-E010101)*(1-E001101)*(1-E100101)*(1-E000001)*(E011101*E101101*E110101*E111001*E000101*E001001*E010001*E100001) * \
                (1-E111110)*(1-E110010)*(1-E101010)*(1-E011010)*(1-E010110)*(1-E001110)*(1-E100110)*(1-E000010)*(E011110*E101110*E110110*E111010*E000110*E001010*E010010*E100010) * \
                E111100*E110000*E101000*E011000*E010100*E001100*E100100*E000000 * (1-E011100)*(1-E101100)*(1-E110100)*(1-E111000)*(1-E000100)*(1-E001000)*(1-E010000)*(1-E100000)


        denom = (1-E111111)*(1-E110011)*(1-E101011)*(1-E011011)*(1-E010111)*(1-E001111)*(1-E100111)*(1-E000011)*(E011111*E101111*E110111*E111011*E000111*E001011*E010011*E100011) * \
                E111101*E110001*E101001*E011001*E010101*E001101*E100101*E000001 * (1-E011101)*(1-E101101)*(1-E110101)*(1-E111001)*(1-E000101)*(1-E001001)*(1-E010001)*(1-E100001) * \
                E111110*E110010*E101010*E011010*E010110*E001110*E100110*E000010 * (1-E011110)*(1-E101110)*(1-E110110)*(1-E111010)*(1-E000110)*(1-E001010)*(1-E010010)*(1-E100010) * \
                (1-E111100)*(1-E110000)*(1-E101000)*(1-E011000)*(1-E010100)*(1-E001100)*(1-E100100)*(1-E000000)*(E011100*E101100*E110100*E111000*E000100*E001000*E010000*E100000)


    else:
        print('Order not yet implemented, change estimation method to probabilities.')
        return np.nan
    
    if ((num==0) & (denom==0)):
            return np.nan 
    elif num==0:
        return -np.inf
    elif denom==0:
        return np.inf
    else:
        return np.log(num/denom)


def calcInteraction_expectations(conditionedGenes):
    '''
    Calc the interactions from the conditioned data using expectation values. 
    Could see if using probabilities is faster. 
    Currently, orders are implemented separately.

    NOTE: previously, each interactions was corrected by a factor to match the {-1, 1} basis of the Ising model.
    I now just take logs and leave them in the {0, 1} basis, which makes more sense for gene expression.
    '''
    
    order = len(conditionedGenes.columns)
    
    if(order==1):
        E = conditionedGenes.iloc[:].mean()[0]
        num = E
        denom = 1-E
        
    elif(order==2):
        E1 = conditionedGenes[conditionedGenes.iloc[:, 1]==1].iloc[:, 0].mean()
        E0 = conditionedGenes[conditionedGenes.iloc[:, 1]==0].iloc[:, 0].mean()

        num = E1*(1-E0)
        denom = E0*(1-E1)
        
    elif(order==3):
        E11 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2]]==1).all(axis=1)].iloc[:, 0].mean()
        E00 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2]]==0).all(axis=1)].iloc[:, 0].mean()
        
        E10 = conditionedGenes[(conditionedGenes.iloc[:, 1]==1) & (conditionedGenes.iloc[:, 2]==0)].iloc[:, 0].mean()
        E01 = conditionedGenes[(conditionedGenes.iloc[:, 1]==0) & (conditionedGenes.iloc[:, 2]==1)].iloc[:, 0].mean()
        
        num = E11*(1-E01)*E00*(1-E10)
        denom = E01*(1-E11)*E10*(1-E00)
        
    elif(order==4):
        E111 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==1).all(axis=1)].iloc[:, 0].mean()
        E000 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==0).all(axis=1)].iloc[:, 0].mean()
        
        E001 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==[0, 0, 1]).all(axis=1)].iloc[:, 0].mean()
        E010 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==[0, 1, 0]).all(axis=1)].iloc[:, 0].mean()
        E100 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==[1, 0, 0]).all(axis=1)].iloc[:, 0].mean()
        
        E011 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==[0, 1, 1]).all(axis=1)].iloc[:, 0].mean()
        E101 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==[1, 0, 1]).all(axis=1)].iloc[:, 0].mean()
        E110 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3]]==[1, 1, 0]).all(axis=1)].iloc[:, 0].mean()
        
       
        num = E111*(1-E011)*(1-E101)*E001*E010*(1-E110)*E100*(1-E000)
        denom = (1-E111)*E011*E101*(1-E001)*(1-E010)*E110*(1-E100)*E000
        
    elif(order==5):
        E1111 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==1).all(axis=1)].iloc[:, 0].mean()
        E0000 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==0).all(axis=1)].iloc[:, 0].mean()
        
        E0001 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[0, 0, 0, 1]).all(axis=1)].iloc[:, 0].mean()
        E0010 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[0, 0, 1, 0]).all(axis=1)].iloc[:, 0].mean()
        E0100 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[0, 1, 0, 0]).all(axis=1)].iloc[:, 0].mean()
        E1000 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[1, 0, 0, 0]).all(axis=1)].iloc[:, 0].mean()
        
        E0011 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[0, 0, 1, 1]).all(axis=1)].iloc[:, 0].mean()
        E0101 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[0, 1, 0, 1]).all(axis=1)].iloc[:, 0].mean()
        E0110 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[0, 1, 1, 0]).all(axis=1)].iloc[:, 0].mean()
        E1010 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[1, 0, 1, 0]).all(axis=1)].iloc[:, 0].mean()
        E1100 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[1, 1, 0, 0]).all(axis=1)].iloc[:, 0].mean()
        E1001 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[1, 0, 0, 1]).all(axis=1)].iloc[:, 0].mean()
        
        E1110 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[1, 1, 1, 0]).all(axis=1)].iloc[:, 0].mean()
        E1101 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[1, 1, 0, 1]).all(axis=1)].iloc[:, 0].mean()
        E1011 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[1, 0, 1, 1]).all(axis=1)].iloc[:, 0].mean()
        E0111 = conditionedGenes[(conditionedGenes.iloc[:, [1, 2, 3, 4]]==[0, 1, 1, 1]).all(axis=1)].iloc[:, 0].mean()
        
        num = E1111*E1100*E1010*E0110*E0101*E0011*E1001*E0000 * (1-E0111)*(1-E1011)*(1-E1101)*(1-E1110)*(1-E0001)*(1-E0010)*(1-E0100)*(1-E1000)
        denom = (1-E1111)*(1-E1100)*(1-E1010)*(1-E0110)*(1-E0101)*(1-E0011)*(1-E1001)*(1-E0000)*(E0111*E1011*E1101*E1110*E0001*E0010*E0100*E1000)

    else:
        print('Order not yet implemented, change estimation method to probabilities.')
        return np.nan

    if ((num==0) & (denom==0)):
            return np.nan 
    elif num==0:
        return -np.inf
    elif denom==0:
        return np.inf
    else:
        return np.log(num/denom)


def calcInteraction_expectations_np(conditionedGenes):
    '''
    Same as calcInteraction_expectations, but much faster
    '''
    
    order = len(conditionedGenes.columns)
    
    conditionedGenes_np = conditionedGenes.values
    
    
    if(order==1):
        E = conditionedGenes_np[:].mean()
        num = E
        denom = 1-E
        
    elif(order==2):
        E1 = conditionedGenes_np[conditionedGenes_np[:, 1]==1][:, 0].mean()
        E0 = conditionedGenes_np[conditionedGenes_np[:, 1]==0][:, 0].mean()

        num = E1*(1-E0)
        denom = E0*(1-E1)
        
    elif(order==3):
        E11 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2]]==1).all(axis=1)][:, 0].mean()
        E00 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2]]==0).all(axis=1)][:, 0].mean()
        
        E10 = conditionedGenes_np[(conditionedGenes_np[:, 1]==1) & (conditionedGenes_np[:, 2]==0)][:, 0].mean()
        E01 = conditionedGenes_np[(conditionedGenes_np[:, 1]==0) & (conditionedGenes_np[:, 2]==1)][:, 0].mean()
        
        num = E11*(1-E01)*E00*(1-E10)
        denom = E01*(1-E11)*E10*(1-E00)
        
    elif(order==4):
        E111 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==1).all(axis=1)][:, 0].mean()
        E000 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==0).all(axis=1)][:, 0].mean()
        
        E001 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==[0, 0, 1]).all(axis=1)][:, 0].mean()
        E010 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==[0, 1, 0]).all(axis=1)][:, 0].mean()
        E100 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==[1, 0, 0]).all(axis=1)][:, 0].mean()
        
        E011 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==[0, 1, 1]).all(axis=1)][:, 0].mean()
        E101 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==[1, 0, 1]).all(axis=1)][:, 0].mean()
        E110 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3]]==[1, 1, 0]).all(axis=1)][:, 0].mean()
        
       
        num = E111*(1-E011)*(1-E101)*E001*E010*(1-E110)*E100*(1-E000)
        denom = (1-E111)*E011*E101*(1-E001)*(1-E010)*E110*(1-E100)*E000
        
    elif(order==5):
        E1111 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==1).all(axis=1)][:, 0].mean()
        E0000 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==0).all(axis=1)][:, 0].mean()
        
        E0001 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[0, 0, 0, 1]).all(axis=1)][:, 0].mean()
        E0010 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[0, 0, 1, 0]).all(axis=1)][:, 0].mean()
        E0100 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[0, 1, 0, 0]).all(axis=1)][:, 0].mean()
        E1000 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[1, 0, 0, 0]).all(axis=1)][:, 0].mean()
        
        E0011 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[0, 0, 1, 1]).all(axis=1)][:, 0].mean()
        E0101 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[0, 1, 0, 1]).all(axis=1)][:, 0].mean()
        E0110 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[0, 1, 1, 0]).all(axis=1)][:, 0].mean()
        E1010 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[1, 0, 1, 0]).all(axis=1)][:, 0].mean()
        E1100 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[1, 1, 0, 0]).all(axis=1)][:, 0].mean()
        E1001 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[1, 0, 0, 1]).all(axis=1)][:, 0].mean()
        
        E1110 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[1, 1, 1, 0]).all(axis=1)][:, 0].mean()
        E1101 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[1, 1, 0, 1]).all(axis=1)][:, 0].mean()
        E1011 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[1, 0, 1, 1]).all(axis=1)][:, 0].mean()
        E0111 = conditionedGenes_np[(conditionedGenes_np[:, [1, 2, 3, 4]]==[0, 1, 1, 1]).all(axis=1)][:, 0].mean()
        
        num = E1111*E1100*E1010*E0110*E0101*E0011*E1001*E0000 * (1-E0111)*(1-E1011)*(1-E1101)*(1-E1110)*(1-E0001)*(1-E0010)*(1-E0100)*(1-E1000)
        denom = (1-E1111)*(1-E1100)*(1-E1010)*(1-E0110)*(1-E0101)*(1-E0011)*(1-E1001)*(1-E0000)*(E0111*E1011*E1101*E1110*E0001*E0010*E0100*E1000)

    else:
        print('Order not yet implemented, change estimation method to probabilities.')
        return np.nan

    if ((num==0) & (denom==0)):
            return np.nan 
    elif num==0:
        return -np.inf
    elif denom==0:
        return np.inf
    else:
        return np.log(num/denom)


def calcInteraction_binTrick(conditionedGenes):
    order = len(conditionedGenes.columns)
    nStates = 2**order
    if order==1:
        binCs = np.bincount(conditionedGenes.values.flatten(), minlength=nStates)
        if sum(binCs==0)>0:
            return np.nan
        else:
            return np.log(binCs[1]/binCs[0])
    
    elif order==2:
        binCs = np.bincount(2 * conditionedGenes.iloc[:, 0] +  conditionedGenes.iloc[:, 1], minlength=nStates)
        if sum(binCs==0)>0:
            return np.nan
        else:
            return np.log(binCs[0]*binCs[3]/(binCs[1]*binCs[2]))
    
    elif order==3:
        binCs = np.bincount(4 * conditionedGenes.iloc[:, 0] + 2 * conditionedGenes.iloc[:, 1] +  conditionedGenes.iloc[:, 2], minlength=nStates)
        if sum(binCs==0)>0:
            return np.nan
        else:
            return np.log(np.prod(binCs[[1, 2, 4, 7]])/np.prod(binCs[[0, 3, 5, 6]]))

    else:
        print('Order not implemented, using even slower order-agnostic version!')

        return calcInteraction_binTrick_allOrders(conditionedGenes)


def calcInteraction_binTrick_allOrders(conditionedGenes):
    # This function is relatively slow compared to using expectation values, but will work for any order of interactions. 

    order = len(conditionedGenes.columns)
    # This assigns every state to numerator or denominator, depending on the number of 1s:
    # In numerator: states where the number of ones has same parity as order itself. 
    # In denom: When this is not the case.
    powers = 2*np.array([np.base_repr(i).count('1')%2==order%2 for i in range(2**order)]).astype(float)-1
    
    binCounts = fastBinCount(conditionedGenes.values.astype(np.float32), order=order)
        
    return np.log(np.prod(np.array([x**p for (x, p) in zip(binCounts, powers)])))  


def calcInteraction_withCI_andBounds(genes, graph, dataSet, estimator, genesToOne=[], dataDups=0, boundBool=0, asympBool=0, nResamps=1000):
    '''
    Add 95% confidence interval bounds and F-value from bootstrap resamples, or asymptotic approximation.
    To check for function equality, you need to use bytecode.
    '''
    
    '''
    if condition:
        if estimator.__code__.co_code == calcInteraction_expectations.__code__.co_code:
            MBmode = '0' # Use first gene to get MB
        elif estimator.__code__.co_code == calcInteraction_expectations_np.__code__.co_code:
            MBmode = '0' # Use first gene to get MB
        elif estimator.__code__.co_code == calcInteraction_expectations_numba.__code__.co_code:
            MBmode = '0' # Use first gene to get MB
        else:
            MBmode = 'All' # Use MB of all genes -- safer, so used as else statement.
        conditionedGenes = conditionOnMB(genes, graph, dataSet, mode=MBmode, genesToOne=genesToOne)
    else:
        conditionedGenes = dataSet.iloc[:, genes]
    '''
    
    conditionedGenes = dataSet.iloc[:, genes]
    # conditionedGenes = conditionOnMB(genes, graph, dataSet, mode=MBmode, genesToOne=genesToOne)
    
    # Check if data needs to be duplicated
    dupFactor=1
    # automatically decide on the duplication factor to reach min bin size of ${dataDups}
    if dataDups>0:
        binCounts = fastBinCount(conditionedGenes.values.astype(np.float32), order=len(conditionedGenes.columns))
        minBin = min(binCounts)

        try:
            if np.floor(dataDups/minBin)>1:
                dupFactor = int(np.floor(dataDups/minBin))
            else:
                dupFactor = 1
        except:
            dupFactor = 1
    # duplicate data
    if dupFactor>1:
        conditionedGenes = pd.concat([conditionedGenes for _ in range(dupFactor)])

    # Numba estimator needs numpy input
    if estimator.__code__.co_code == calcInteraction_expectations_numba.__code__.co_code:
        val0 = estimator(conditionedGenes.values)
    else:
        val0 = estimator(conditionedGenes)
    
    # Stores if estimate is real val: 0, or UB/LB: 1/-1
    boundVal = 0

    if np.isnan(val0):
        # Then both num and denom are zero and we can't do anything
        return [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, genes]


    if np.isinf(val0):

        # If empirical is +/- inf, then we can add artificial cells to put bounds.
        # This is not yet statistically analysed or proven, so proceed carefully with this option.
        if boundBool:
            order = len(genes)
            binCounts = binCounts = fastBinCount(conditionedGenes.values.astype(np.float32), order=order)

            # find the binary rep of the state that was missing, and see if we can put upper/lower bound
            boundVal = -1*int(np.sign(val0))
            statesToAdd = np.array([np.array(list(np.binary_repr(i, order))).astype(int) for i in range(2**order)])[np.where(binCounts==0)[0]]
            conditionedGenes = conditionedGenes.append(pd.DataFrame(statesToAdd, columns=conditionedGenes.columns), ignore_index=True)
        
        # if not considering bounds, just return nans
        else:
            return [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, genes]

    # Asymptotic estimation
    if asympBool:
        binCounts = fastBinCount(conditionedGenes.values.astype(np.float32), order=len(conditionedGenes.columns))
        # Asymptotic standard error of log-odds ratios
        se = np.sqrt(sum([1/x for x in binCounts]))
        CI = (val0 - 1.96*se, val0 + 1.96*se)
        if val0>=0:
            propDifSign = norm.cdf(0, loc=val0, scale=se)
        else:
            propDifSign = 1-norm.cdf(0, loc=val0, scale=se)

        propUndefined = 0
        propInfinite = 0

    # Bootstrap estimation
    else:
        vals = np.zeros(nResamps)
        # Numba needs numpy random numbers:
        if estimator.__code__.co_code == calcInteraction_expectations_numba.__code__.co_code:
            rng = np.random.default_rng()
            conditionedGenes_np = conditionedGenes.values
            for i in range(nResamps):
                resampled = conditionedGenes_np[rng.choice(len(conditionedGenes_np), len(conditionedGenes_np), replace=True)]
                vals[i] = estimator(resampled)
        # The other functions can use pandas' random numbers:
        else:
            for i in range(nResamps):
                genes_resampled = conditionedGenes.sample(frac=1, replace=True)
                vals[i] = estimator(genes_resampled)
    
        vals.sort()
        vals_noNan = vals[~np.isnan(vals)]

        # Correcting for the reduced variance if the data was duplicated
        if dupFactor>1:
            vals = np.sqrt(dupFactor)*(vals-val0) + val0
        
        # Defines the 95% confidence interval 
        CI = (vals_noNan[int(np.around(len(vals_noNan)/40))], vals_noNan[int(np.floor(len(vals_noNan)*39/40))])

        propDifSign = sum(np.sign(vals_noNan)==-np.sign(val0))/len(vals_noNan)
        propUndefined = sum(np.isnan(vals))/len(vals)
        propInfinite = sum(np.isinf(vals))/len(vals)

    return [val0, CI[0], CI[1], propDifSign, propUndefined, propInfinite, boundVal, genes]

def calcInteraction_withCI_parallel(args):
    '''
    wrapper to unpack function arguments so that it can be mapped over process pool with one arg.
    (I actually think there should be something like executor.starmap that could do this for us)
    '''
    genes, graph, dataSet, estimator, nResamps, genesToOne, dataDups, boundBool, asympBool = args

    return calcInteraction_withCI_andBounds(genes=genes, graph=graph, dataSet=dataSet, estimator=estimator, genesToOne=genesToOne, dataDups=dataDups, boundBool=boundBool, nResamps=nResamps, asympBool=asympBool) 


# Bootstrap algorithm for dendrogram resampling:

'''
Below: the PVclust algorithm implementation, and some helper functions. 
'''

from math import sqrt
from multiprocessing import Pool, cpu_count
import pandas as pd
import numpy as np

from scipy.stats import norm, chi2
from scipy.cluster.hierarchy import (dendrogram, set_link_color_palette,
                                     leaves_list, to_tree, linkage)
import matplotlib.pyplot as plt

from sklearn.linear_model import LinearRegression
from scipy.cluster import _hierarchy
import scipy.spatial.distance as distance
import warnings

# First, I need to modify the scipy linkage function so that undefined distances are manually set to 1, the maximum. 
def _convert_to_double(X):
    if X.dtype != np.double:
        X = X.astype(np.double)
    if not X.flags.contiguous:
        X = X.copy()
    return X

def _warning(s):
    warnings.warn('scipy.cluster: %s' % s, ClusterWarning, stacklevel=3)

_LINKAGE_METHODS = {'single': 0, 'complete': 1, 'average': 2, 'centroid': 3,
                    'median': 4, 'ward': 5, 'weighted': 6}
_EUCLIDEAN_METHODS = ('centroid', 'median', 'ward')

def myLinkage(y, method='single', metric='euclidean', optimal_ordering=False):
    if method not in _LINKAGE_METHODS:
        raise ValueError("Invalid method: {0}".format(method))

    y = _convert_to_double(np.asarray(y, order='c'))
    # if y.ndim == 1:
        # distance.is_valid_y(y, throw=True, name='y')
        # [y] = _copy_arrays_if_base_present([y])
    # elif y.ndim == 2:
    if y.ndim == 2:
        if method in _EUCLIDEAN_METHODS and metric != 'euclidean':
            raise ValueError("Method '{0}' requires the distance metric "
                             "to be Euclidean".format(method))
        if y.shape[0] == y.shape[1] and np.allclose(np.diag(y), 0):
            if np.all(y >= 0) and np.allclose(y, y.T):
                _warning('The symmetric non-negative hollow observation '
                         'matrix looks suspiciously like an uncondensed '
                         'distance matrix')
        y = distance.pdist(y, metric)

        # This is the only real change I implemented:
        y[np.isnan(y)]=1
        
    else:
        raise ValueError("`y` must be 2 dimensional.")

    if not np.all(np.isfinite(y)):
        raise ValueError("The condensed distance matrix must contain only "
                         "finite values.")

    n = int(distance.num_obs_y(y))
    method_code = _LINKAGE_METHODS[method]

    if method == 'single':
        result = _hierarchy.mst_single_linkage(y, n)
    elif method in ['complete', 'average', 'weighted', 'ward']:
        result = _hierarchy.nn_chain(y, n, method_code)
    else:
        result = _hierarchy.fast_linkage(y, n, method_code)


    # I have commented this out; I don't need it.
    # if optimal_ordering:
    #     return optimal_leaf_ordering(result, y)
    # else:
    return result



"""
Modified from https://github.com/aturanjanin/pvclust/blob/master/pvclust.py

The original algorithm is implemented in R by Suzuki and Shimodira (2006):
Pvclust: an R package for assessing the uncertanity in hierarchical
clustering. This is its Python reimplementation. The final values produced are
Approximately Unbiased p-value (AU) and Bootstrap Probability (BP) which
are reporting the significance of each cluster in clustering structure.
The AU value is less biased and clusters that have this value greater than
95% are considered significant.

Both values are calculated using Multiscale Bootstrap Resampling.
"""


class PvClust:
    """ Calcuclate AU and BP probabilities for each cluster of the data."""
    def __init__(self, data, method='ward', metric='euclidean',
                 nboot=1000, r=np.array(range(5, 15)), parallel=False):
        """Parameters:
            - data : DataFrame
              a dataset to which clustering and sampling are applied
            - method: a linkage method used in hierarchical clustering
            - metric: a distance metric used in hierarchical clustering
            - nboot: a number of bootstrap samples
            - r: an array of scaling constants
            - parallel: boolean value stating should the algorithm run in
            parallel

        :returns Approximately Unbiased p-value and Bootstrap Probability for
        every dendrogram node.
        :rtype dict
        """

        self.data = data
        self.nboot = nboot   # number of bootstrap replicates
        self.parallel = parallel

        self.n = len(self.data)
        r = np.array([i/10 for i in r])
        self.n_scaled = np.unique([int(i*self.n) for i in r])
        self.r = np.unique([i/self.n for i in self.n_scaled])

        # apply hierarchical clustering and get clusters
        self.metric, self.method = metric, method
        hc = HierarchicalClusteringClusters(data.transpose(), method, metric)
        self.linkage_matrix = hc.linkage_matrix
        self.clusters = hc.find_clusters()

        self._result = self._result()
        self.result = self._result

    def _hc(self, n):
        """ Do bootstrap sampling and then apply hierarchical clustering
        to the sample """
        data = self.data
        # we are sampling instances
        data = data.sample(n, replace=True, axis=0)
        # HC is applied to columns each time (hence transposing)
        temp = HierarchicalClusteringClusters(data.transpose(), self.method,
                                              self.metric)
        clusters = temp.find_clusters()

        return clusters

    def _nbootstrap_probability(self, n):
        """ Calculate bootstrap probability of each cluster for the dataset of
        size n """
        # dictionary for counting repetitions of the same clusters throughout
        # nboot different clusterings
        repetitions = {i: 0 for i in range(len(self.clusters))}

        # do HC nboot times for dataset of size n
        for _ in range(self.nboot):
            sample_clusters = self._hc(n)
            # compare obtained clusters with the main ones and
            # update repetitions if necessary
            for cluster in sample_clusters:
                if cluster in self.clusters:
                    repetitions[self.clusters.index(cluster)] += 1

        # calculate BP probability for each cluster for the sample of size n
        BP = [repetitions[k]/self.nboot for k in repetitions.keys()]

        return np.array(BP)

    def _table(self):
        """ Make a table of bootstrap probabilities for each sample size"""
        # for each sample size in n_scaled calculate BPs of all clusters and
        # add it to the table
        if self.parallel:
            print(f"Calculating using {cpu_count()} cores... ", end="")
            with Pool() as pool:
                probabilities = pool.map(self._nbootstrap_probability,
                                         self.n_scaled)

            table = probabilities[0]
            for i in probabilities[1::]:
                table = np.column_stack((table, i))
            print("Done.")
        else:
            table = np.empty([len(self.data.transpose())-1, 1])
            for i in self.n_scaled:
                print(f"Boostrap (r = {round(i/ self.n, 2)}) ... ", end="")
                temp = self._nbootstrap_probability(i)
                table = np.column_stack((table, temp))
                print("Done.")
            table = np.delete(table, 0, 1)
        return table

    def _wls_fit(self):
        """ Take all calculated bootstrap probabilities of a single cluster and
        fit a curve to it in order to calculate AU and BP for that cluster"""
        nboot, r = self.nboot, self.r
        r_sq_org = np.array([sqrt(j) for j in r])
        r_isq_org = np.array([1/sqrt(j) for j in r])
        eps = 0.001
        table = self._table()

        result = {}
        for i in range(len(table)):
            BP = table[i]
            nboot_list = np.repeat(nboot, len(BP))
            use = np.logical_and(np.greater(BP, eps), np.less(BP, 1-eps))

            if sum(use) < 3:
                au_bp = np.array([0, 0]) if np.mean(BP) < 0.5 else \
                    np.array([1, 1])
                result[i] = np.concatenate((au_bp, np.array([0, 0, 0, 0, 0])))
            else:
                BP = BP[use]
                r_sq = r_sq_org[use]
                r_isq = r_isq_org[use]
                nboot_list = nboot_list[use]

                y = -norm.ppf(BP)
                X_model = np.array([[i, j] for i, j in zip(r_sq, r_isq)])
                weight = ((1-BP)*BP)/((norm.pdf(y)**2)*nboot_list)

                model = LinearRegression(fit_intercept=False)
                results_lr = model.fit(X_model, y, sample_weight=1/weight)
                z_au = np.array([1, -1])@results_lr.coef_
                z_bp = np.array([1, 1])@results_lr.coef_
                # AU and BP
                au_bp = np.array([1-norm.cdf(z_au), 1-norm.cdf(z_bp)])

                Xw = [i/j for i, j in zip(X_model, weight)]
                temp = X_model.transpose()@Xw
                V = np.linalg.solve(temp, np.identity(len(temp)))
                vz_au = np.array([1, -1])@V@np.array([1, -1])
                vz_bp = np.array([1, 1])@V@np.array([1, 1])
                # estimted standard errors for p-values
                se_au = norm.pdf(z_au)*sqrt(vz_au)
                se_bp = norm.pdf(z_bp)*sqrt(vz_bp)

                # residual sum of squares
                y_pred = results_lr.predict(X_model)
                rss = sum((y - y_pred)**2/weight)
                df = sum(use) - 2  # degrees of freedom
                pchi = 1 - chi2.cdf(rss, df) if (df > 0) else 1.0

                result[i] = np.concatenate(
                    (au_bp, np.array([se_au, se_bp, pchi]), results_lr.coef_))

        return result

    def _result(self):
        # calculate AU and BP values
        result = pd.DataFrame.from_dict(
            self._wls_fit(), orient="index",
            columns=['AU', 'BP', 'SE.AU', 'SE.BP', 'pchi', 'v', 'c'])
        return result

    def plot(self, labels=None):
        """Plot dendrogram with AU BP values for each node"""
        plot_dendrogram(self.linkage_matrix,
                        np.array(self.result[['AU', 'BP']]), labels)
#         plot_dendrogram(self.linkage_matrix,
#                         np.array(self.result[['AU', 'BP']]), labels)

    def seplot(self, pvalue='AU', annotate=False):
        """p-values vs Standard error plot"""
        x = self.result['AU'] if pvalue == 'AU' else self.result['BP']
        y = self. result['SE.AU'] if pvalue == 'AU' else self.result['SE.BP']
        clusters = []

        plt.scatter(x, y, facecolors='none', edgecolors='r')
        plt.title("p-value vs Standard Error plot")
        plt.xlabel(pvalue + " p-value")
        plt.ylabel("Standard Error")
        if annotate:
            for i in range(len(y)):
                if y[i] > 0.6:
                    plt.text(x[i], y[i], f"{i}")
                    clusters.append(i)
        plt.show()
        if clusters:
            return clusters

    def print_result(self, which=[], digits=3):
        """Print only desired clusters and/or print values to the desired
        decimal point"""
        print(" Clustering method:", self.method, "\n", "Distance metric:",
              self.metric, "\n", "Number of replicates:", self.nboot, "\n")
        results = round(self._result, digits)

        if not which:
            print(results)
        else:
            print(results.iloc[which, ])


class HierarchicalClusteringClusters:
    """Apply Hierarhical Clustering on the data and find elements of
    each cluster"""
    def __init__(self, data, method='ward', metric='euclidean'):

        self.linkage_matrix = myLinkage(data, method, metric)
        self.nodes = to_tree(self.linkage_matrix, rd=True)[1]

    def l_branch(self, left, node, nodes):
        if not node.is_leaf():
            if node.left.id > (len(nodes)-1)/2:
                self.l_branch(left, nodes[node.left.id], nodes)
                self.r_branch(left, nodes[node.left.id], nodes)
            else:
                left.append(node.left.id)
        else:
            left.append(node.id)

        return list(set(left))

    def r_branch(self, right, node, nodes):
        if not node.is_leaf():
            if node.right.id > (len(nodes)-1)/2:
                self.r_branch(right, nodes[node.right.id], nodes)
                self.l_branch(right, nodes[node.right.id], nodes)
            else:
                right.append(node.right.id)
        else:
            right.append(node.id)

        return list(set(right))

    # find all clusters produced by HC from leaves to the root node
    def find_clusters(self):
        nodes = self.nodes
        clusters = []
        for i in range(len(leaves_list(self.linkage_matrix)), len(nodes)):
            left = self.l_branch([], nodes[i], nodes)
            right = self.r_branch([], nodes[i], nodes)

            node_i = sorted(set(left + right))
            if node_i:
                clusters.append(node_i)

        return clusters


def plot_dendrogram(linkage_matrix, pvalues, labels=None):
    """ Plot dendrogram with AU BP values for each node"""
    d = dendrogram(linkage_matrix, no_plot=True)
    xcoord = d["icoord"]
    ycoord = d["dcoord"]
    # Obtaining the coordinates of all nodes above leaves
    x = {i: (j[1]+j[2])/2 for i, j in enumerate(xcoord)}
    y = {i: j[1] for i, j in enumerate(ycoord)}
    pos = node_positions(y, x)

    plt.figure(figsize=(24, 20))
    plt.tight_layout()
    set_link_color_palette(['c', 'g'])
    d = dendrogram(linkage_matrix, labels=labels, above_threshold_color='c',
                   color_threshold=0.1)
    ax = plt.gca()
    for node, (x, y) in pos.items():

        if node == (len(pos.items())-1):
            ax.text(x-6, y+5, 'AU', fontsize=11, fontweight='bold',
                    color='purple')
            ax.text(x+1, y+5, 'BP', fontsize=11, fontweight='bold',
                    color='black')
        else:
            if pvalues[node][0]*100 >= 95:
                ax.text(x-5, y+5, f' {pvalues[node][0]*100:.0f}', fontsize=8,
                        color='purple', fontweight='bold')
                ax.text(x+1, y+5, f'{pvalues[node][1]*100:.0f}', fontsize=8,
                        color='black', fontweight='bold')
            else:
                ax.text(x-5, y+5, f' {pvalues[node][0]*100:.0f}', fontsize=8,
                        color='purple')
                ax.text(x+1, y+5, f'{pvalues[node][1]*100:.0f}', fontsize=8,
                        color='black')
#    plt.savefig('dendrogram.pdf')


def node_positions(x, y):
    positions = {**x, **y}
    for key, value in positions.items():
        if key in x and key in y:
            positions[key] = (value, x[key])

    positions = sorted(positions.items(), key=lambda x: x[1][1])
    pos = {i: positions[i][1] for i in range(len(positions))}

    return pos














